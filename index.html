<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Rep Calculator</title>

    <!-- Bootstrap 5 CSS (CDN) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">


    <!-- jQuery (CDN) - Required for jQuery Knob -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"
            integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

    <!-- jQuery Knob (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/jquery-knob@1.2.11/dist/jquery.knob.min.js"
            integrity="sha256-2144q+NOM/XU6ZxSqRTJ8P0W/CkY6zXc6mXYt4+mF9s=" crossorigin="anonymous"></script>

    <style>
        /* Make sure the knobs section occupies the full viewport height */
        #knobs-section {
            height: 100vh;
            display: flex;
            flex-wrap: wrap;
            align-items: center; /* Vertically center the content */
            justify-content: center; /* Horizontally center the content */
        }

        .knob-container {
            text-align: center;
            margin: 1rem 0;
        }

        .knob-label {
            margin-top: 0.5rem;
            font-weight: 500;
        }

        /* Adjust knob sizes for responsiveness */
        .knob {
            width: 150px;
            height: 150px;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .knob {
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>

<body>
<!-- Header / Title / Instructions -->
<header class="bg-light py-4">
    <div class="container">
        <h1 class="text-center">Rep Calculator</h1>
        <p class="text-center lead">
            Enter your current and desired reps/weight below using the knobs.
        </p>
    </div>
</header>

<!-- Main Content: Knobs Section -->
<section id="knobs-section" class="container-fluid">
    <!-- Row to hold 4 sectors -->
    <div class="row w-100">
        <div class="col-12 col-md-4">
            <div id="slider"></div>
            <div class="mt-3">
                <strong>Selected Range:</strong>
                <span id="range-value"></span>
            </div>
        </div>
        <div class="w-100"></div>
        <!-- Current Reps -->
        <div class="col-12 col-md-6 knob-container">
            <div class="knob-label">Current Reps</div>
            <input
                    type="text"
                    class="knob"
                    value="15"
                    data-thickness="0.4"

                    data-cursor=10
                    data-min="5"
                    data-max="30"
                    data-angleOffset=-125
                    data-angleArc=250
                    data-fgColor="#007bff"
                    data-bgColor="#e9ecef"
                    id="knob-current-reps"
            />

        </div>

        <!-- Current Weight -->
        <div class="col-12 col-md-6 knob-container">
            <div class="knob-label">Current Weight</div>
            <input
                    type="text"
                    class="knob"
                    value="70"
                    data-thickness="0.4"
                    data-stopper="false"
                    data-cursor=10
                    data-min="1"
                    data-max="500"
                    data-fgColor="#007bff"
                    data-bgColor="#e9ecef"
                    id="knob-current-weight"
            />

        </div>

        <!-- Wanted Reps -->
        <div class="col-12 col-md-6 knob-container">
            <div class="knob-label">Wanted Reps</div>
            <input
                    type="text"
                    class="knob"
                    value="12"
                    data-thickness="0.4"

                    data-cursor=10
                    data-min="5"
                    data-max="30"
                    data-angleOffset=-125
                    data-angleArc=250
                    data-fgColor="#007bff"
                    data-bgColor="#e9ecef"
                    id="knob-wanted-reps"
            />

        </div>

        <!-- Wanted Weight -->
        <div class="col-12 col-md-6 knob-container">
            <div class="knob-label">Wanted Weight</div>
            <input
                    type="text"
                    class="knob"
                    value="120"
                    data-thickness="0.4"

                    data-cursor=10
                    data-min="1"
                    data-max="500"
                    data-angleOffset=-125
                    data-angleArc=250
                    data-fgColor="#007bff"
                    data-bgColor="#e9ecef"
                    id="knob-wanted-weight"
            />

        </div>
    </div>
</section>

<!-- Bootstrap 5 JS (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.8.1/dist/nouislider.min.js"
        integrity="sha256-eSIpJ8t2lfQDFEtY4x2mpwgtguCNMQsM13YmTTEavn0=" crossOrigin="anonymous"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.8.1/dist/nouislider.min.css"
      integrity="sha256-nckVXP1jMdH1YpiBrAvGOSgkP6TB2DsXzkkhtSAL4K4=" crossorigin="anonymous">
<script>

    function pchipInterpolate(xArray, yArray, xValue) {
        if (xArray.length !== yArray.length) {
            throw new Error("xArray and yArray must have the same length.");
        }

        const n = xArray.length;
        if (xValue < xArray[0] || xValue > xArray[n - 1]) {
            throw new Error("xValue is out of bounds.");
        }

        // Helper function to compute derivatives
        function computeDerivatives(x, y) {
            const n = x.length;
            const derivatives = new Array(n).fill(0);
            const slopes = new Array(n - 1);

            for (let i = 0; i < n - 1; i++) {
                slopes[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
            }

            derivatives[0] = slopes[0];
            derivatives[n - 1] = slopes[n - 2];

            for (let i = 1; i < n - 1; i++) {
                if (slopes[i - 1] * slopes[i] > 0) {
                    const weightedAvg =
                        (2 * slopes[i - 1] * slopes[i]) / (slopes[i - 1] + slopes[i]);
                    derivatives[i] = weightedAvg;
                }
            }
            return {derivatives, slopes};
        }

        const {derivatives, slopes} = computeDerivatives(xArray, yArray);

        // Locate the interval
        let i = 0;
        while (i < n - 1 && xValue > xArray[i + 1]) {
            i++;
        }

        const h = xArray[i + 1] - xArray[i];
        const t = (xValue - xArray[i]) / h;

        // Cubic Hermite spline interpolation formula
        const h00 = (1 + 2 * t) * Math.pow(1 - t, 2);
        const h10 = t * Math.pow(1 - t, 2);
        const h01 = Math.pow(t, 2) * (3 - 2 * t);
        const h11 = Math.pow(t, 2) * (t - 1);

        const yValue =
            h00 * yArray[i] +
            h10 * h * derivatives[i] +
            h01 * yArray[i + 1] +
            h11 * h * derivatives[i + 1];

        return yValue;
    }

    function reversePchipInterpolate(yArray, xArray, yValue) {
        if (xArray.length !== yArray.length) {
            throw new Error("xArray and yArray must have the same length.");
        }

        const n = yArray.length;
        if (yValue < yArray[n - 1] || yValue > yArray[0]) {
            throw new Error("yValue is out of bounds.");
        }

        // Helper function to compute derivatives
        function computeDerivatives(x, y) {
            const n = x.length;
            const derivatives = new Array(n).fill(0);
            const slopes = new Array(n - 1);

            for (let i = 0; i < n - 1; i++) {
                slopes[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
            }

            derivatives[0] = slopes[0];
            derivatives[n - 1] = slopes[n - 2];

            for (let i = 1; i < n - 1; i++) {
                if (slopes[i - 1] * slopes[i] > 0) {
                    const weightedAvg =
                        (2 * slopes[i - 1] * slopes[i]) / (slopes[i - 1] + slopes[i]);
                    derivatives[i] = weightedAvg;
                }
            }
            return {derivatives, slopes};
        }

        const {derivatives} = computeDerivatives(xArray, yArray);

        // Locate the interval where yValue falls
        let i = 0;
        while (i < n - 1 && yValue < yArray[i + 1]) {
            i++;
        }

        // Solve for x using Newton's method
        const h = xArray[i + 1] - xArray[i];
        const y0 = yArray[i];
        const y1 = yArray[i + 1];
        const d0 = derivatives[i];
        const d1 = derivatives[i + 1];

        function cubicHermite(t) {
            const h00 = (1 + 2 * t) * Math.pow(1 - t, 2);
            const h10 = t * Math.pow(1 - t, 2);
            const h01 = Math.pow(t, 2) * (3 - 2 * t);
            const h11 = Math.pow(t, 2) * (t - 1);
            return h00 * y0 + h10 * h * d0 + h01 * y1 + h11 * h * d1;
        }

        function cubicHermiteDerivative(t) {
            const h00 = 6 * t * (t - 1);
            const h10 = (1 - 4 * t + 3 * t * t) * h;
            const h01 = -6 * t * (t - 1);
            const h11 = (3 * t * t - 2 * t) * h;
            return h00 * y0 + h10 * d0 + h01 * y1 + h11 * d1;
        }

        // Start Newton's method
        let t = 0.5; // Start in the middle of the interval
        let yEstimate = cubicHermite(t);
        let iterations = 0;
        const maxIterations = 100;
        const tolerance = 1e-6;

        while (Math.abs(yEstimate - yValue) > tolerance && iterations < maxIterations) {
            const dy = cubicHermiteDerivative(t);
            if (Math.abs(dy) < tolerance) break; // Avoid division by near-zero
            t -= (yEstimate - yValue) / dy;
            t = Math.max(0, Math.min(1, t)); // Clamp t to [0, 1]
            yEstimate = cubicHermite(t);
            iterations++;
        }

        if (iterations >= maxIterations) {
            throw new Error("Newton's method did not converge.");
        }

        return xArray[i] + t * h;
    }


    // Custom function for Google Sheets
    // function PCHIP(xValue, xArray, yArray) {
    //     return pchipInterpolate(xArray.map(Number), yArray.map(Number), Number(xValue));
    // }
    const y = [100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15];
    const x = [1, 3.28, 4.94, 7.15, 9.75, 12.37, 14.8, 17.11, 19.53, 22.43, 25.99, 30.37, 35.75, 42.37, 50.50, 60.48, 72.75, 87.79];
    let counter = 0;
    let minReps = 5;
    let maxReps = 30;

    let v, up = 0, down = 0, i = 1
        // ,$idir = $("div.idir")
        // ,$ival = $("div.ival")
        , incr = function () {
            i++;
            console.log(i);
            //$ival.html(i);
        }
        , decr = function () {
            i--;
            console.log(i);
            //$ival.html(i);
        };

    const changeFunc = function (v, tp, $this) {
        if (counter > 0) {
            return;
        }
        counter++;
        let currentReps = $('#knob-current-reps').val();
        let currentWeight = $('#knob-current-weight').val();
        let wantedReps = $('#knob-wanted-reps').val();
        let wantedWeight = $('#knob-wanted-weight').val();
        let currentPercentage = pchipInterpolate(x, y, currentReps);
        console.log("any change");
        console.log($this.attr('id'));
        if ($this.attr('id') == 'knob-current-weight') {
            console.log("currentweight");
            if (v > this.cv) {
                if (up) {
                    incr();
                    up = 0;
                } else {
                    up = 1;
                    down = 0;
                }
            } else {
                if (v < this.cv) {
                    if (down) {
                        decr();
                        down = 0;
                    } else {
                        down = 1;
                        up = 0;
                    }
                }
            }
            this.cv = v;
            //$('#knob-current-weight').val(i)

        }
        if ($this.attr('id') == 'knob-wanted-weight') {

            let wantedPercentage = wantedWeight / currentWeight * currentPercentage;
            if (wantedPercentage > 100) {
                $('#knob-wanted-reps').val("Too much weight");
            } else if (wantedPercentage < 15) {
                $('#knob-wanted-reps').val("Too little weight");
            } else {
                // console.log(wantedPercentage);
                let newReps = Math.round(reversePchipInterpolate(y, x, wantedPercentage));
                $('#knob-wanted-reps').val(newReps).trigger('change');
            }
        } else {
            if ($this.attr('id') != 'knob-wanted-reps' && tp == 'change') {
                let minPercentage = pchipInterpolate(x, y, maxReps);
                let maxPercentage = pchipInterpolate(x, y, minReps);
                $('#knob-wanted-weight').trigger('configure', {
                    max: Math.floor(currentWeight / currentPercentage * maxPercentage),
                    min: Math.ceil(currentWeight / currentPercentage * minPercentage),
                });
            }
            let wantedPercentage = pchipInterpolate(x, y, wantedReps);
            let newWeight = currentWeight / currentPercentage * wantedPercentage;
            $('#knob-wanted-weight')
                .val(Math.round(newWeight * 10) / 10)
                .trigger('change');
            // .attr('data-max', Math.floor(currentWeight / currentPercentage * 100))
            // .attr('data-min', Math.ceil(currentWeight / currentPercentage * 15))
            //.trigger('change');
            // $('#knob-wanted-weight');
            // console.log({
            //     max: Math.floor(currentWeight / currentPercentage * 100),
            //     min: Math.ceil(currentWeight / currentPercentage * 15),
            // });
        }
        counter--;
    };
    $(function () {
        // Initialize all knobs
        let height = Math.floor($(document).height() / 2);
        let width = Math.floor($('.knob-container').width() / 2);
        height = width = Math.min(height, width);
        //$($('.knob-container')[0]).width()


        $(".knob").each(function () {
            let $this = $(this);
            $this.knob({
                'change': (v) => {
                    changeFunc(v, 'change', $this)
                },
                'release': (v) => {
                    changeFunc(v, 'release', $this)
                },
                'width': width,
                'height': height,
                'draw': function () {
                    console.log(this);
                    // Draw the min value
                    var min = this.o.min;
                    var max = this.o.max;

                    // Set the canvas context
                    var ctx = this.g;

                    // Min value position
                    ctx.font = "bold 60px Arial";
                    ctx.fillStyle = "#000000"; // Text color
                    ctx.textAlign = "center";
                    // ctx.fillText(min+"", this.w*0.4, this.h-50);
                    ctx.textAlign = "left";
                    ctx.fillText(min+"", this.w*0.5, this.h*2*0.9);
                    ctx.textAlign = "right";
                    ctx.fillText(max+"", this.w*2-this.w*0.5, this.h*2*0.9);
                }
            });
        });
        const slider = $('#slider')[0];

        noUiSlider.create(slider, {
            start: [5, 30], // Initial range
            connect: true, // Connect the range between handles
            range: {
                min: 1,
                max: 87
            },
            tooltips: [true, true], // Display tooltips on handles
            step: 1 // Increment steps
        });


// Update the range value dynamically
        const $rangeValue = $('#range-value');
        slider.noUiSlider.on('update', function (values) {
            $rangeValue.text(`${Math.round(values[0])} - ${Math.round(values[1])}`);
            minReps = values[0];
            maxReps = values[1];
            let knobsConf = {
                min: Math.round(values[0]),
                max: Math.round(values[1]),
            };
            $('#knob-wanted-reps').trigger('configure', knobsConf).trigger('change');
            $('#knob-current-reps').trigger('configure', knobsConf).trigger('change');
            let currentReps = $('#knob-current-reps').val();
            let currentWeight = $('#knob-current-weight').val();
            let currentPercentage = pchipInterpolate(x, y, currentReps);
            let minPercentage = pchipInterpolate(x, y, maxReps);
            let maxPercentage = pchipInterpolate(x, y, minReps);
            $('#knob-wanted-weight').trigger('configure', {
                max: Math.floor(currentWeight / currentPercentage * maxPercentage),
                min: Math.ceil(currentWeight / currentPercentage * minPercentage),
            }).trigger('change');
        });
    });
</script>
</body>
</html>
